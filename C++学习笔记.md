# C++学习笔记

## 一、C++基础

### 1) 常见数据类型

1. bool 类型一个字节，起始只是占用了一个位 ,最小尺寸：未定义

2. char字符类型，占用一个字节 ，8位

3. short 短整型，占用两个字节 ，16位

4. int 整型，占用四个字节 ，16位

5. long 长整型，占4个字节 ，32位

6. float,单精度浮点型，占用4个字节，6位有效数字 

7. double,双精度浮点型，占用8个字节 ，10位有效数字

8. 关于unsigned 无符号类型数据，出现负数如何处理？

   ```C++
   unsigned char -1
   则-1=1000 0001，符号位不变，其余位取反再加1：1111 1111
   ```


### 2）指针

**1.指针的大小：32位操作系统下是4个字节；**

2.==指向常量的指针==(pointer to const), 所谓指针常量，指针的指向可以改，指针指向的值不可以改

```C++
int a = 10;        //const修饰的是指针
const int *p1 = &a;//指向常量的指针，仅仅指不能通过该指针来改变对象的值，不代表该对象不能					  //通过其他途径来改变
```

3.常量指针(const pointer)：==必须要初始化==，指针指向不可以改，指针指向的值可以更改

```C++
int a = 10;			//const修饰的是常量
int * const p2 = &a;//从右往左看，离p2最近的是const，说明p2是一个常量，*说明p2是一个指					//针
```

4 . const既修饰指针又修饰常量：指针的指向和指向的值都不可以改哦！

```C++
const double pi = 3.14;
const double *const double pip = &pi;//指向常量的常量指针
```

> Tips:从右往左读，*指Pointer，const指常量，根据英文意思来理解实际含义及作用。

5.顶层const:指的是本身不可以被改变

  底层const:自身所指的对象不可以被改变

==用于声明引用的const都是底层const==.

***\*顶层const的拷贝不受限制\**，但是\**底层const的拷贝的对象必须具有相同的底层const资格。\**一般来说\**：非常量可以赋值给常量，反之则不行\****

6.auto和decltype的异同：

1）如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。

2）decltype(())双括号的差别，双括号或者赋值表示引用。

```C++
int i = 0, &r = i;
// same
auto a = i;        //int a = 0;
decltype(i) b = i; //int b = 0;
// different
auto c = r;		   //int c = 0;
decltype(r) d = i; //int &d = i;
```

7.string 类的输入运算符：自动忽略开头的空白，直到遇到下一个空白；逐个输出单词，每个单词后面都紧跟一个换行。

 getline:直接读取一行，保留输入的空白符，直到遇到换行符，换行符也被都进来了，但是不存到那个string对象中去。

8.范围for语句:**不应改变其所遍历的序列的大小**

```C++
for (auto &w : svec)
		for (auto &c : w)
			c = toupper(c);
```

9.vector和数组都有类似的迭代器，begin指向首元素，end指向尾元素的==“下一位置”==，**不可以进行解引用和递增操作**。

10.**==注意区分==**:原则==从内向外，从右向左==

```C++
int *p[4];//p是一个数组，里面含有4个整型的指针
int (*p)[4];//p是一个指针，里面含有4个整数

//范围for循环
int ia[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
for (const int (&row) [4] : ia)//row是一个引用，引用的是ia的第一个含有4个整型常量的数组
```

11. **c++中明确规定了逻辑与(&&)、逻辑或(||)、条件运算符(?:)、逗号运算符(，)这四种运算符的求值顺序**

1）a && b:先判断a为真，再判断b为真；

2）a||b:先左后右；

12.**左值与右值**：左值和右值主要的区别之一是左值可以被修改，而右值不能。

[(64条消息) 理解C和C++中的左值和右值_xuwqiang1994的博客-CSDN博客_左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310)

==左值==：在内存中占有一块确定内存的对象；eg:赋值运算符、前置递增、箭头运算符

==右值==：不在内存中占有确定内存的表达式。eg:逻辑、关系、算术运算符、后置递增将原来副本作为右值、点运算符根据成员所属对象是左值还是右值来分。

> 左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量
>
> > - 左值是可寻址的变量，有持久性；
> > - 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。

## 3）函数

1.定义变量，如果未被显示初始化，默认初值由它的位置决定。即在函数体外，被默认初始化为0，在函数体内，则不被初始化，是未定义的一个值。

2.函数指针：

1）指向函数的指针：

```C++
typedef int(*p) (int a, int b);
typedef decltype(add) *p;//二者等价
```

2）返回指向函数的指针：

```C++
decltype(sumlength) *getFcn(const string&);
```

## 4）类

1.是否返回引用？

```C++
inline 
Screen& Screen::set(char c)
{
	contents[cursor] = c;
    return *this;
}//解引用this后，返回引用，则可以对对象进行修改
//如果不返回引用，则对它的操作只是对副本的操作，并不会修改到原对象
Screen Screen::set(char c){}
```

2.关于友元（我的博客）：

[(64条消息) 2021-08-21_xxb201710的博客-CSDN博客](https://blog.csdn.net/xxb201710/article/details/119837048?spm=1001.2014.3001.5501)

## 二、关于智能指针的一些知识点

### 1） shared_ptr

==**1）make_shared()函数**==：最安全的分配和使用动态内存的方法，此函数在动态内存中分配一个对象并初始化它，返回指向该对象的shared_ptr，头文件为memory

```cpp
shared_ptr<int> p3 = make_shared<int>(42);//p3为智能指针，指向一个值为42的对象
auto p3 = make_shared<int>(42);//利用auto比较简便，若不传递任何参数，会值初始化
```

每个shared_ptr都有一个关联的计数器，称为引用计数，个人理解就是该对象被引用的次数，拷贝情况下会递增：

1：用一个shared_ptr初始化另一个shared_ptr(拷贝)

2：将一个shared_ptr传递给一个函数当参数，值传递(拷贝)

3：作为函数的返回值，(返回的是自身的拷贝，也就是活引用的次数+1)

计数器递减情况：

1：给shared_ptr赋予一个新值(也就是说自身指向了另外一个地址，原来指向的对象已经没有引用者，则会自动释放)

2：一个shared_ptr离开其作用域时，会被销毁(递减)

当一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象，前提是其指向的对象只有一个引用者。

==**2）使用动态内存的原因**==：让多个对象共享相同的底层数据。也就是说拷贝的情况虽然发生，但是并不是元素的拷贝，而是将本身的指向拷贝给另一个指针对象，让这一个对象也指向自己所指向的对象，这样在本身释放以后，还有另一个对象指向自身原来所指向的对象。

==**3）理解变量的销毁与其内存的释放之间的关系**== 内置类型的指针在离开作用域时，本身会被销毁，但其指向的内存空间什么都不会发生，必须以显式的delete进行释放空间。智能指针在离开作用域时，本身也会被销毁，并且计数器减一，当其计数器为0且只有一个智能指针指向该对象时，该对象的内存空间会被释放。如若用智能指针的get()函数得到的一个内置指针来初始化一个临时的智能指针，一旦该内置指针被释放，指向的内存也会被释放，原来的智能指针就会变成空指针。**永远不要用get初始化另一个智能指针或是给智能指针赋值！**

### 2) unique_ptr

**1)**：unique_ptr拥有其所指向的对象，属于一一对应关系，unique_ptr被销毁时，其对象也会被销毁，unique_ptr不支持拷贝和赋值，必须==采用直接初始化==的方式，当我们定义一个unique_ptr时，必须将其绑定到一个new返回的指针上





## 三、构造与析构
**1）**构造函数中，成员初始化是在函数体执行之前完成的，且按照他们在类内出现的顺序进行初始化，析构函数中，首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁，所以析构函数可以执行设计者想要的任何收尾工作，再销毁成员

**2）**==析构函数体自身并不直接销毁成员，是在析构函数体执行完毕之后隐式的析构阶段中被销毁的==

**3) ** 关于main( int argc, char* argv[], char **env )血统最纯正的写法：

[(88条消息) 关于int main( int argc, char* argv[\] ) 中arg和argv参数的解析及调试_一树荼蘼的博客-CSDN博客](https://blog.csdn.net/dgreh/article/details/80985928)

**4）**合成默认构造函数真相

[C++ 合成默认构造函数的真相 - melonstreet - 博客园 (cnblogs.com)](https://www.cnblogs.com/QG-whz/p/4676481.html)

